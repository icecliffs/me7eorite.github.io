import{_ as o,c as k,J as i,m as a,a as s,w as t,V as l,E as e,o as c}from"./chunks/framework.WH0rnJL5.js";const f=JSON.parse('{"title":"Java原生反序列化与反序列化漏洞","description":"","frontmatter":{},"headers":[],"relativePath":"笔记/👮🏻网络安全/Java/反序列化/Basic/Java原生反序列化与反序列化漏洞.md","filePath":"笔记/👮🏻网络安全/Java/反序列化/Basic/Java原生反序列化与反序列化漏洞.md"}'),d={name:"笔记/👮🏻网络安全/Java/反序列化/Basic/Java原生反序列化与反序列化漏洞.md"},_=a("h1",{id:"java原生反序列化与反序列化漏洞",tabindex:"-1"},[s("Java原生反序列化与反序列化漏洞 "),a("a",{class:"header-anchor",href:"#java原生反序列化与反序列化漏洞","aria-label":'Permalink to "Java原生反序列化与反序列化漏洞"'},"​")],-1),g=l('<h2 id="_1-序列化与反序列化" tabindex="-1">1.序列化与反序列化 <a class="header-anchor" href="#_1-序列化与反序列化" aria-label="Permalink to &quot;1.序列化与反序列化&quot;">​</a></h2><blockquote><ul><li><p>序列化分为两大部分：序列化和反序列化。</p><ul><li><p><strong>序列化</strong>：是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。</p></li><li><p><strong>反序列化</strong>：是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。</p></li></ul></li><li><p>总结：</p><ul><li><p><strong>Java序列化</strong>:把Java对象转换为字节序列的过程。</p></li><li><p><strong>Java反序列化</strong>:把字节序列恢复为Java对象的过程。</p></li></ul></li></ul></blockquote><blockquote><p><strong>为什么需要序列化与反序列化？</strong> 我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的。如何做到呢？这就需要Java序列化与反序列化了。换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p><p>当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><p>① 想把内存中的对象保存到一个文件中或者数据库中时候； ② 想用套接字在网络上传送对象的时候； ③ 想通过RMI传输对象的时候</p></blockquote><h2 id="_2-代码实现" tabindex="-1">2.代码实现 <a class="header-anchor" href="#_2-代码实现" aria-label="Permalink to &quot;2.代码实现&quot;">​</a></h2>',4),v=l(`<div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> pass</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>在上述代码中，<code>Serializable</code>接口的代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>它是Java提供的序列化接口，一个空接口，用来作为类是否可序列化与反序列化的标识。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2>`,5),b=a("h2",{id:"贡献者",tabindex:"-1"},[s("贡献者 "),a("a",{class:"header-anchor",href:"#贡献者","aria-label":'Permalink to "贡献者"'},"​")],-1),B=a("h2",{id:"文件历史",tabindex:"-1"},[s("文件历史 "),a("a",{class:"header-anchor",href:"#文件历史","aria-label":'Permalink to "文件历史"'},"​")],-1);function u(y,C,m,D,E,A){const p=e("NolebasePageProperties"),n=e("VPNolebaseInlineLinkPreview"),h=e("NolebaseGitContributors"),r=e("NolebaseGitChangelog");return c(),k("div",null,[_,i(p),g,a("p",null,[s("由于序列化的操作单位是对象，所以我们需要先构造一个User实体类，部分代码("),i(n,{href:"https://github.com/Me7eorite/Learning-Demo/blob/main/JavaStudy/src/main/java/com/learning/serialization/primer/User.java",target:"_blank",rel:"noreferrer"},{default:t(()=>[s("完整代码")]),_:1}),s(")内容如下：")]),v,a("p",null,[i(n,{href:"https://blog.csdn.net/mocas_wang/article/details/107621010",target:"_blank",rel:"noreferrer"},{default:t(()=>[s("java序列化与反序列化全讲解")]),_:1})]),b,i(h),B,i(r)])}const P=o(d,[["render",u]]);export{f as __pageData,P as default};
