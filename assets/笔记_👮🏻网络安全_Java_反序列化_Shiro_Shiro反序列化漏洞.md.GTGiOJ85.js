import{_ as p,c as r,J as s,m as e,a as i,V as c,o as l,E as a}from"./chunks/framework.WH0rnJL5.js";const h="/assets/image-20240205194735982.O3e-S0l9.png",g="/assets/image-20240205202219424.ITWxYWB2.png",m="/assets/image-20240205203157528.EbpC-Ocz.png",d="/assets/image-20240205203341408.Tm7iUnFp.png",k="/assets/image-20240205203638823.ioc6aYfm.png",_="/assets/image-20240205204001184.KkNa4GXE.png",u="/assets/image-20240205204113469.hwoy0K-x.png",b="/assets/image-20240205205023452.MbaFV32X.png",B="/assets/image-20240205205132280.ETJF3u6D.png",y="/assets/image-20240205205243607.HyB2uz1o.png",x="/assets/image-20240205205515277.MuCAx7N1.png",A="/assets/image-20240205205743290.KNIgoUtd.png",S="/assets/image-20240205210009980.2_4tZvsj.png",C="/assets/image-20240206164059084.OA4m7xsP.png",E="/assets/image-20240206164218957.aShpCIe8.png",f="/assets/image-20240206164333000.ofvFf34J.png",v="/assets/image-20240206164535759.MmxaYqIa.png",j="/assets/image-20240206164439682.vk-seE4o.png",D=JSON.parse('{"title":"Shiro反序列化漏洞","description":"","frontmatter":{},"headers":[],"relativePath":"笔记/👮🏻网络安全/Java/反序列化/Shiro/Shiro反序列化漏洞.md","filePath":"笔记/👮🏻网络安全/Java/反序列化/Shiro/Shiro反序列化漏洞.md"}'),P={name:"笔记/👮🏻网络安全/Java/反序列化/Shiro/Shiro反序列化漏洞.md"},F=e("h1",{id:"shiro反序列化漏洞",tabindex:"-1"},[i("Shiro反序列化漏洞 "),e("a",{class:"header-anchor",href:"#shiro反序列化漏洞","aria-label":'Permalink to "Shiro反序列化漏洞"'},"​")],-1),I=c(`<h2 id="_0x01-前言" tabindex="-1">0x01 前言 <a class="header-anchor" href="#_0x01-前言" aria-label="Permalink to &quot;0x01 前言&quot;">​</a></h2><p>Shiro-550反序列化漏洞大约在2016年就被披露了，但感觉直到近一两年，在各种攻防演练中这个漏洞才真正走进了大家的视野，Shiro-550反序列化应该可以算是这一两年最好用的RCE漏洞之一，原因有很多：Shiro框架使用广泛，漏洞影响范围广；攻击payload经过AES加密，很多安全防护设备无法识别/拦截攻击……</p><h2 id="_0x02-环境搭建" tabindex="-1">0x02 环境搭建 <a class="header-anchor" href="#_0x02-环境搭建" aria-label="Permalink to &quot;0x02 环境搭建&quot;">​</a></h2><p>直接从github上clone代码到本地。</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>git clone https://github.com/apache/shiro.git</span></span>
<span class="line"><span>cd shiro</span></span>
<span class="line"><span>git checkout shiro-root-1.2.4</span></span></code></pre></div><p>编辑shiro/samples/web目录下的pom.xml,将jstl的版本修改为1.2。</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;javax.servlet&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;jstl&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;1.2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">scope</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;runtime&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">scope</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre></div><h2 id="_0x03-漏洞分析" tabindex="-1">0x03 漏洞分析 <a class="header-anchor" href="#_0x03-漏洞分析" aria-label="Permalink to &quot;0x03 漏洞分析&quot;">​</a></h2><p>网上的分析文章都会直接告诉我们触发点在XXX，如果参考文章，那我们可能说找到触发点，然后往下跟就完事了。</p><p>这样看起来似乎我们好像学习到了，但是真的了解这个洞了吗？所以不妨从如何发现来分析出这个漏洞。</p><p>第一种方式就在于我们可以根据报错来进行分析，首先如果对与rememberMe该字段传输的内容中，如果存在一些异常的错误，会存在以下异常</p><p><img src="`+h+'" alt="image-20240205194735982"></p><p>那么根据这个报错链，我们需要定位到的就在于<code>createSubject(SubjectContext subjectContext)</code>,然后往下跟踪基本上就可以找到该反序列化链的触发。</p><h3 id="_3-1-加密过程" tabindex="-1">3.1 加密过程 <a class="header-anchor" href="#_3-1-加密过程" aria-label="Permalink to &quot;3.1 加密过程&quot;">​</a></h3><p>首先断点可以设置在<code>shiro/core/src/main/java/org/apache/shiro/subject/support/DelegatingSubject#login(AuthenticationToken token)</code></p><p><img src="'+g+'" alt="image-20240205202219424"></p><p>继续往下跟着调用，到<code>shiro/core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager#login(Subject subject, AuthenticationToken token)</code></p><p><img src="'+m+'" alt="image-20240205203157528"></p><p>往下调用到<code>onSuccessfulLogin(token, info, loggedIn);</code>,继续跟着调用就是到同一个类下的<code>onSuccessfulLogin(AuthenticationToken token, AuthenticationInfo info, Subject subject)</code>中，紧接着调用<code>rememberMeSuccessfulLogin(token, info, subject);</code>中。</p><p><img src="'+d+'" alt="image-20240205203341408"></p><p>根据上述代码，首先获取<code>CookieRememberMeManager</code>对象，当该类不为空，往下调用<code>onSuccessfulLogin(subject, token, info);</code>，该方法主要的代码为</p><p><img src="'+k+'" alt="image-20240205203638823"></p><p>通过forgetIndentity方法，对subject对象进行处理，该对象包含单个用户的状态和安全操作，其中包括认证、授权等等。那么我们有必要跟进这个方法分析处理方式。</p><p>获取请求包和响应包后，再次调用forgetIndentity方法，处理这两个获取到的包。</p><p><img src="'+_+'" alt="image-20240205204001184"></p><p>通过getCookie方法获取到cookie之后再通过removeFrom方法，在返回包中添加Set-Cookie: rememberMe=deleteMe</p><p><img src="'+u+'" alt="image-20240205204113469"></p><p>然后回到onSuccessfulLogin方法中，如果有设置rememberMe则进入rememberIdentity方法。</p><p><img src="'+b+'" alt="image-20240205205023452"></p><p>通过调用<code>convertPrincipalsToBytes</code>对用户名进行处理，然后调用serialize对用户名进行处理。</p><p><img src="'+B+'" alt="image-20240205205132280"></p><p>然后在serialize方法中，对于用户名再进行处理。</p><p><img src="'+y+'" alt="image-20240205205243607"></p><p>回到<code>convertPrincipalsToBytes</code>方法中，再对序列化的数据进行加密。跟进<code>encrypt(byte[] serialized)</code>中，通过加密算法为AES，模式为CBC，填充算法为PKCS5Padding</p><p><img src="'+x+'" alt="image-20240205205515277"></p><p>通过<code> getEncryptionCipherKey()</code>获取加密密钥，该密钥可以在<code>AbstractRememberMeManager.java</code>文件中看到。</p><p><img src="'+A+'" alt="image-20240205205743290"></p><p>返回到rememberIdentity方法中，跟进rememberSerializedIdentity方法中，然后将加密后的内容进行base64加密然后设置到cookie中。</p><p><img src="'+S+'" alt="image-20240205210009980"></p><p>然后就结束了。</p><h3 id="_3-2-解密过程" tabindex="-1">3.2 解密过程 <a class="header-anchor" href="#_3-2-解密过程" aria-label="Permalink to &quot;3.2 解密过程&quot;">​</a></h3><p>断点可以设置在<code>shiro/core/src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager#getRememberedPrincipals(SubjectContext subjectContext)</code>中</p><p><img src="'+C+'" alt="image-20240206164059084"></p><p>首先通过<code>getRememberedSerializedIdentity</code>方法获取解码之后的值</p><p><img src="'+E+'" alt="image-20240206164218957"></p><p>获取密钥并且判断是否为空，如果不为空调用解密函数，对加密后的内容进行处理。</p><p><img src="'+f+'" alt="image-20240206164333000"></p><p>然后调用反序列化，需要注意的是这里的反序列化是有一些区别的，重写了ObjectInputStream</p><p><img src="'+v+'" alt="image-20240206164535759"></p><p>调用readObject也会进入resolveClass方法。</p><p><img src="'+j+'" alt="image-20240206164439682"></p><h2 id="贡献者" tabindex="-1">贡献者 <a class="header-anchor" href="#贡献者" aria-label="Permalink to &quot;贡献者&quot;">​</a></h2>',52),M=e("h2",{id:"文件历史",tabindex:"-1"},[i("文件历史 "),e("a",{class:"header-anchor",href:"#文件历史","aria-label":'Permalink to "文件历史"'},"​")],-1);function N(T,q,V,z,J,R){const t=a("NolebasePageProperties"),n=a("NolebaseGitContributors"),o=a("NolebaseGitChangelog");return l(),r("div",null,[F,s(t),I,s(n),M,s(o)])}const G=p(P,[["render",N]]);export{D as __pageData,G as default};
